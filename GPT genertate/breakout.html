<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brick Breaker - Mini Game</title>
  <style>
    :root{--bg:#111;--panel:#0f1724;--accent:#10b981;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071019 0%, #071827 100%);color:#e6eef6}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
    .card{background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6);width:900px;max-width:100%}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
    h1{font-size:18px;margin:0}
    .controls{font-size:13px;color:var(--muted)}
    canvas{display:block;background:linear-gradient(180deg,#022 0%, #00303a 100%);border-radius:8px;width:100%;height:560px}
    .footer{display:flex;justify-content:space-between;padding-top:10px;color:var(--muted);font-size:13px}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#022;cursor:pointer;font-weight:600}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>Brick Breaker — Bản mini</h1>
        <div class="controls">Phím ← → hoặc chuột để di chuyển • Space để bắt đầu/tạm dừng</div>
      </header>

      <canvas id="game"></canvas>

      <div class="footer">
        <div>Score: <span id="score">0</span> &nbsp;|&nbsp; Lives: <span id="lives">3</span></div>
        <div>
          <button id="restart">Chơi lại</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const restartBtn = document.getElementById('restart');

  // Responsive canvas (keeps consistent logical size but fits width)
  function resize() {
    const maxWidth = Math.min(900, window.innerWidth - 80);
    canvas.width = maxWidth;
    canvas.height = Math.min(600, Math.max(420, Math.floor(maxWidth * 0.62)));
  }
  window.addEventListener('resize', resize);
  resize();

  // Game state
  let score = 0;
  let lives = 3;
  let running = false;
  let lastTime = 0;

  // Paddle
  const paddle = {
    width: 120,
    height: 14,
    x: 0,
    y: 0,
    speed: 8
  };

  // Ball
  const ball = {
    r: 8,
    x: 0,
    y: 0,
    vx: 4,
    vy: -4
  };

  // Bricks
  let bricks = [];
  const brickCfg = {
    rows: 5,
    cols: 9,
    padding: 8,
    offsetTop: 40,
    offsetLeft: 28,
    height: 18
  };

  function buildBricks() {
    bricks = [];
    for (let r = 0; r < brickCfg.rows; r++) {
      const row = [];
      for (let c = 0; c < brickCfg.cols; c++) {
        row.push({alive: true});
      }
      bricks.push(row);
    }
    // adjust brick width based on canvas
    const totalPad = brickCfg.padding * (brickCfg.cols - 1);
    const available = canvas.width - brickCfg.offsetLeft * 2 - totalPad;
    brickCfg.width = Math.floor(available / brickCfg.cols);
  }

  function resetPositions() {
    paddle.width = Math.max(64, Math.min(160, Math.floor(canvas.width * 0.14)));
    paddle.x = (canvas.width - paddle.width) / 2;
    paddle.y = canvas.height - paddle.height - 20;

    ball.x = canvas.width / 2;
    ball.y = paddle.y - ball.r - 2;
    ball.vx = 4 * (Math.random() > 0.5 ? 1 : -1);
    ball.vy = -4;
  }

  function startNewGame() {
    score = 0;
    lives = 3;
    running = false;
    buildBricks();
    resetPositions();
    updateUI();
    draw();
  }

  function updateUI() {
    scoreEl.textContent = score;
    livesEl.textContent = lives;
  }

  // Input
  const keys = {left:false,right:false};
  document.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'Space') running = !running;
  });
  document.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
  });

  // mouse move
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    paddle.x = mx - paddle.width / 2;
    clampPaddle();
  });

  // touch support
  canvas.addEventListener('touchmove', (e) => {
    if (!e.touches.length) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.touches[0].clientX - rect.left;
    paddle.x = mx - paddle.width / 2;
    clampPaddle();
    e.preventDefault();
  }, {passive:false});

  function clampPaddle(){
    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
  }

  // collision helpers
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function update(dt) {
    // paddle movement via keys
    if (keys.left) paddle.x -= paddle.speed;
    if (keys.right) paddle.x += paddle.speed;
    clampPaddle();

    // ball move
    if (running) {
      ball.x += ball.vx;
      ball.y += ball.vy;

      // wall collisions
      if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -1; }
      if (ball.x + ball.r > canvas.width) { ball.x = canvas.width - ball.r; ball.vx *= -1; }
      if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -1; }

      // paddle collision
      if (rectsOverlap(ball.x - ball.r, ball.y - ball.r, ball.r*2, ball.r*2, paddle.x, paddle.y, paddle.width, paddle.height)){
        // reflect depending on hit position
        const hitPos = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2); // -1 .. 1
        const speed = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
        const maxAngle = Math.PI * 0.35; // 63deg
        const angle = hitPos * maxAngle;
        ball.vx = speed * Math.sin(angle);
        ball.vy = -Math.abs(speed * Math.cos(angle));
        // slight speed increase
        ball.vx *= 1.02;
        ball.vy *= 1.02;
        // nudge ball above paddle
        ball.y = paddle.y - ball.r - 1;
      }

      // bricks collision
      outer: for (let r = 0; r < bricks.length; r++){
        for (let c = 0; c < bricks[r].length; c++){
          const b = bricks[r][c];
          if (!b.alive) continue;
          const bx = brickCfg.offsetLeft + c * (brickCfg.width + brickCfg.padding);
          const by = brickCfg.offsetTop + r * (brickCfg.height + brickCfg.padding);
          if (rectsOverlap(ball.x - ball.r, ball.y - ball.r, ball.r*2, ball.r*2, bx, by, brickCfg.width, brickCfg.height)){
            // determine simple collision side by comparing previous position
            // reflect Y if hit top/bottom, else reflect X
            const prevX = ball.x - ball.vx;
            const prevY = ball.y - ball.vy;
            const collidedHoriz = prevY >= by && prevY <= by + brickCfg.height;
            if (collidedHoriz) ball.vx *= -1; else ball.vy *= -1;

            b.alive = false;
            score += 10;
            updateUI();
            break outer;
          }
        }
      }

      // bottom -> lose life
      if (ball.y - ball.r > canvas.height) {
        lives -= 1;
        updateUI();
        running = false;
        if (lives <= 0) {
          // game over
          setTimeout(()=>{
            alert('Game over! Score: ' + score);
            startNewGame();
          }, 10);
        } else {
          // reset ball & paddle
          resetPositions();
        }
      }

      // win check
      const anyAlive = bricks.some(row => row.some(b => b.alive));
      if (!anyAlive) {
        running = false;
        setTimeout(()=>{
          alert('You win! Score: ' + score);
          startNewGame();
        }, 10);
      }
    } else {
      // when not running, stick ball on paddle
      ball.x = paddle.x + paddle.width / 2;
      ball.y = paddle.y - ball.r - 2;
    }
  }

  function drawRoundedRect(x,y,w,h,r){
    const radius = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+radius,y);
    ctx.arcTo(x+w,y,x+w,y+h,radius);
    ctx.arcTo(x+w,y+h,x,y+h,radius);
    ctx.arcTo(x,y+h,x,y,radius);
    ctx.arcTo(x,y,x+w,y,radius);
    ctx.closePath();
    ctx.fill();
  }

  function draw() {
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background subtle gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, 'rgba(0,20,30,0.25)');
    g.addColorStop(1, 'rgba(0,10,20,0.05)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw bricks
    for (let r = 0; r < bricks.length; r++){
      for (let c = 0; c < bricks[r].length; c++){
        const b = bricks[r][c];
        const bx = brickCfg.offsetLeft + c * (brickCfg.width + brickCfg.padding);
        const by = brickCfg.offsetTop + r * (brickCfg.height + brickCfg.padding);
        if (!b.alive) continue;
        // color by row
        const hue = 200 - r * 22;
        ctx.fillStyle = `hsl(${hue} 70% 50%)`;
        drawRoundedRect(bx, by, brickCfg.width, brickCfg.height, 6);
        // inner highlight
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(bx + 4, by + 3, Math.max(0, brickCfg.width - 8), 4);
      }
    }

    // paddle
    ctx.fillStyle = '#10b981';
    drawRoundedRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);

    // ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    // small shine
    ctx.beginPath();
    ctx.arc(ball.x - ball.r*0.35, ball.y - ball.r*0.45, ball.r*0.28, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fill();

    // HUD (top-left)
    ctx.font = '14px system-ui, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillText('Score: ' + score, 12, 22);

    if (!running) {
      ctx.font = '13px system-ui, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.textAlign = 'center';
      ctx.fillText('Space để bắt đầu', canvas.width/2, canvas.height/2 - 10);
      ctx.textAlign = 'left';
    }
  }

  function loop(ts) {
    const dt = Math.min(40, ts - lastTime);
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  restartBtn.addEventListener('click', () => startNewGame());

  // ensure rebuild bricks on resize
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      buildBricks();
      resetPositions();
      draw();
    }, 120);
  });

  // initial
  startNewGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>